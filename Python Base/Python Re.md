#### 匹配括号
```
# 匹配括号里面的内容
https://blog.csdn.net/weixin_43235307/article/details/120219815
# 匹配左括号前的内容
s = "水电费(1000元)1月30日前需要上交"
pat = re.compile(u'.*?(?=\\()')
res = re.match(pat, s)
print(res.group())
# 删除三种括号及里面的内容
text = re.sub(u"\\(.*?\\)|\\{.*?}|\\[.*?]", '', text)
# 匹配"说  明 书"
text = "说  明 书"
text = re.findall(r"说[\s]+明[\s]+书", text)
print(text)
```

#### 只保留中文、英文和指定标点符号
```
con = "b0111111;1:cs<=7'b0000110;2:cs<=7'b1011011;endcase//选定一个数码管//在数码管上显示bs的值."
# []中的^有反选的意思，例如^a-z就是除了a-z之外的，在sub中a-z就不会被去除
cop = re.compile("[^\u4e00-\u9fa5^.^a-z^A-Z^0-9_.!+-=——,$%^，。？、~@#￥%……&*《》<>「」{}【】()/\\\[\]'\"]")
subcon = re.sub(cop, "", con)
print(subcon)
```

#### 字符串的标点符号
```
# 去除英文标点符号
import string
text = 'adfadf,.,d.,sf.;,we;,f;d,fw;efw;elf;wle,fw;'
enbiaodian = string.punctuation
pat = r"[%s]+" % enbiaodian
res = re.sub(pat, "", text)  
print(res)

# 去除中文标点符号
# pip install zhon
from zhon.hanzi import punctuation
text = "中文标点: ！？｡＂＃＄％＆＇（）＊＋，－／：；＜＝＞＠［"
zhbiaodian = punctuation
pat = r"[%s]+" % zhbiaodian
res = re.sub(pat, "", text)  # 去除标点符号
print(res)
```

#### 匹配URL
```
import re
text = "网址是:https://www.baidu.com,欢迎大家访问"
t1 = re.sub("http*\S+", " ", text)  # 删除http及之后
print(t1)
# 匹配常见域名的http或https开头的url
t2 = re.sub(r'(http|https)://(.*?)\.(net|com|cn|org|info|edu|gov|uk|de|ca|jp|fr|au|us|ru|ch|it|nel|se|no|es|mil)', '', text)
print(t2)
# 匹配www开头的url
t3 = re.sub(r'^www\.(.*?)\.(net|com|cn|org|info|edu|gov|uk|de|ca|jp|fr|au|us|ru|ch|it|nel|se|no|es|mil)', '', text)
print(t3)
# 用match匹配带有://前面内容的url，用findall匹配url的各个部分
# \w+匹配任意数字、字母级下划线,等价于 '[^A-Za-z0-9_]'
# ([^/:]+)匹配非/或:的内容
# (:\d*)? 匹配:任意数字0次或1次(考虑到了以ip+端口号的情况，或者域名映射不在服务器80端口的情况)
# ([^# ]*)匹配任意非#和空格内容
t4 = re.match(r"(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)", text)
if t4:
   print(t4.group())
# 其他：
p5 = r"^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&=]*)?"
```

#### 后向引用
```
分类	代码/语法	说明
捕获	(exp)	        匹配exp,并捕获文本到自动命名的组里
        (?<name>exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
        (?:exp)	        匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言	(?=exp)	        匹配exp前面的位置
        (?<=exp)	匹配exp后面的位置
        (?!exp)	        匹配后面跟的不是exp的位置
        (?<!exp)	匹配前面不是exp的位置
注释	(?#comment)	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
# 例1:匹配重复的单词
# (\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，\1代表编号1的分组，即第一个括号(\w+)捕获的内容
s2 = "go go"
p1 = re.compile(r"\b(\w+)\b\s+\1\b")
r1 = re.match(p1, s2)
print(r1.group())

# 例2：获取所有数字段
import re
text1 = "Cats are smarter than dogs A23G4HFD567"
# ?P<>是将后面匹配的\d数据取一个组名，组名必须唯一不重复且没有特殊符号
s = re.findall('(?P<value>\d+)', text1)  # +至少一个，\d数字
print(s)

# 例3:获取路径中包含的某个中间路径之后的内容
import re
pat2 = re.compile('(?<=/yourmidpath).*$')
# 例如:
path = 'D:/test/yourmidpath/needpathorfile'
s1 = re.findall(pat2, path)
print(s1)
# 运行结果
# ['/needpathorfile']

# 例4：将匹配的数字乘以2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)
print(re.sub('(?P<value>\d+)', double, text1))

# 例5：返回身份证号码的省市和出生年份，并转化成{变量名:值}的字典
sfz = "1102231990xxxxxxxx"
res = re.search('(?P<province>\d{3})(?P<city>\d{3})(?P<born_year>\d{4})', sfz)
print(res.groupdict())
```

#### 匹配任意多个空格
```
import re
pat3 = re.compile(r' +')
s1 = '前        后'
s2 = re.sub(' +', ' ', s1)
或者
s2 = re.sub(r'\s+', ' ', s1)
print(s2)
# 运行结果:
# 前 后
```

#### 匹配邮箱
1. 参考：https://blog.csdn.net/make164492212/article/details/51656638
2. 思路：
* 没有统一的邮箱账号格式
* 但是所有邮箱都符合账号@域名的格式
  * 实例1：只允许英文字母、数字、下划线、英文句号以及中划线组成
    * 名称部分：[a-zA-Z0-9_-]+
    * 域名部分：
      * 一般域名规律为[N级域名][三级域名][二级域名][顶级域名]，例如qq.com、163.com、gamil.com、12-34.com.cn，类似** .** .** .**
      * "**"可以用[a-zA-Z0-9_-]+表示
      * ".**"可以用\.[a-zA-Z0-9_-]+表示
      * 多个".**"可以用(\.[a-zA-Z0-9_-]+)+表示
      * 最终格式：[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+
  * 实例2：名称运行汉字、英文字母、数字，域名只允许英文域名
    * 名称部分：[a-zA-Z0-9\u4e00-\u9fa5]+
    * 域名部分：[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+
    * 最终格式：[a-zA-Z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+

#### 电话号码
```
s1 = "(010)88886666"
s2 = "022-22334455"
# \(?，匹配0个或1个(
# 0\d{2}  0和任意两位数字
# [) -]  0个或1个 )、空格、-
p1 = re.compile("\(?0\d{2}[) -]?\d{8}")
r1 = re.match(p1, s1)
if r1:
    print(r1.group())
# 分枝条件：
# 匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)
0\d{2}-\d{8}|0\d{3}-\d{7}
# 匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔
\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}
```

#### IP地址
```
# IP地址中每个数字都不能大于255, IP 地址里的数字可以包含有前导 0
# 这里将255分为了200-249、250-255、000-199，前三部分带.
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
# 校验IP-v4地址
 \\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b
# 校验IP-v6地址
 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))
```

#### 匹配字符串中任意由两个英文字母和四个数字组成的字符串，并将英文和数字分开变为元组形式
```
import re
pat = re.compile('([a-zA-Z]{2})([0-9]{4})')
# 例如：
s1 = 'sf2134dsfs32dsfdfs3421fsdf'
s2 = re.findall(pat, s1)
print(s2)
print(type(s2[0]))
# 运行结果:
# [('sf', '2134'), ('fs', '3421')]
# <class 'tuple'>
```

#### 匹配区域单位名称
```
import re
data_list = ['北京市南瓜村', '陕西省西安市雁塔区大村', '西班牙镇街道', '北京市海淀区', '黑龙江省佳木斯市汤原县大村', '内蒙古自治区赤峰市',
            '贵州省黔南州贵定县', '新疆维吾尔自治区伊犁州奎屯市']
pat = r'([\u4e00-\u9fa5]{2,5}?(?:省|自治区|市)){0,1}([\u4e00-\u9fa5]{2,7}?(?:区|县|州)){0,1}([\u4e00-\u9fa5]{2,7}?(?:村|镇|街)){1}'
for data in data_list:
    pattern = re.compile(pat)
    try:
        m = pattern.search(data)
        print(m.group())
    except:
        continue
```

#### 匹配字符串所有指定字符串，进行修改
```
import re

text1 = "Cats are smarter than dogs A23G4HFD567"

# 获取所有数字段
# ?P<>是将后面匹配的\d数据取一个组名，组名必须唯一不重复且没有特殊符号
s = re.findall('(?P<value>\d+)', text1)  # +至少一个，\d数字
print(s)

# 将匹配的数字乘以2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)

print(re.sub('(?P<value>\d+)', double, text1))

# 返回身份证号码的省市和出生年份，并转化成{变量名:值}的字典
sfz = "1102231990xxxxxxxx"
res = re.search('(?P<province>\d{3})(?P<city>\d{3})(?P<born_year>\d{4})', sfz)
print(res.groupdict())
```

#### 前端标签
```
# 匹配不包含属性的简单HTML标签内里的内容
(?<=<(\w+)>).*(?=<\/\1>)
# 匹配HTML标签
 <\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:".*?"|'.*?'|[\\^'">\\s]+))?)+\\s*|\\s*)\\/?>
```

#### 输出字符串中所有101组成的列表
```
import regex

string = '10010101000132165465101354654101'
str_re = '101'
print(regex.findall(str_re, string, overlapped=True))
```

#### 登录注册模块
```
# 校验密码强度，不能特殊字符，长度限定8-10
pwd_pat = re.compile(^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$)
# 设定用户名规则，包含数字、字母、下划线并限制字符个数,例子是长度为3~15
uname_pat = re.compile('^[1-9a-z_-]{3,15}$')
```

#### 其他
```
删除标签。x = re.sub("#\S+", " ", x)
删除记号和下一个字符。x = re.sub("\'\w+", '', x)
删除标点符号。x = re.sub('[%s]' % re.escape(string.punctuation), ' ', x)
删除数字。x = re.sub(r'\w*\d+\w*', '', x)
替换空格。x = re.sub('\s{2,}', " ", x)
# 校验E-Mail 地址
 email_pattern = '^[*#\u4e00-\u9fa5 a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.[a-zA-Z0-9]{2,6}$'
 [\\w!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?
# 校验身份证号码
# 15位：
 ^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$
# 18位：
 ^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$
 “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。
 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$
# 校验金额，精确到2位小数。
 ^[0-9]+(.[0-9]{2})?$
# 判断IE的版本
 ^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$

# 文件路径及扩展名校验，以txt为例
 ^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?"<>|]+\\.txt(l)?$
# 提取Color Hex Codes（网页中的颜色代码）
 ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$
# 提取网页图片
 \\< *[img][^\\\\>]*[src] *= *[\\"\\']{0,1}([^\\"\\'\\ >]*)
# 提取页面超链接
 (<a\\s*(?!.*\\brel=)[^>]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^"]+)"((?!.*\\brel=)[^>]*)(?:[^>]*)>
# 查找CSS属性
 ^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}
# 抽取注释
 <!--(.*?)-->

```