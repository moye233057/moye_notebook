### 概念
* 多任务实现方式：
  * 多进程模式
  * 多线程模式
  * 协程模式
  * 多进程+多线程模式（不稳定，容易混乱）
* 单核CPU实现多任务：
  * 操作系统轮流让各个任务去交替执行
  * A执行2ms，切换到B，再执行2ms，再切换C，执行2ms，CPU执行太快，导致看起来所有任务在同时执行
* 多核CPU实现多任务：
  * 真正的并行执行多任务是再多核CPU上实现（任务数量<=CPU的核心数量）
  * 如果任务数量远多于CPU的核心数量，会自动把很多的任务轮流调度掉每个核心上执行
* 并发和并行
  * 并发：指一个时间段内，在一个CPU（CPU核心）能运行的程序的数量。
  * 并行：指在同一时刻，在多个CPU上运行多个程序，跟CPU（CPU核心）数量有关。
  * 因为：计算机CPU（CPU核心）在同一时刻只能运行一个程序。

* CPU密集型
  * 也叫计算密集型，指I/O在很短时间就可以完成，CPU需要大量的计算和处理，特点是CPU占用率高 
  * 例如：压缩解压缩、加密解密、正则表达式搜索
* IO密集型
  * 系统运作大部分状况是在等I/O（硬盘/内存）的读/写操作，CPU占用率较低
  * 例如：文件处理程序、网络爬虫程序、读写数据库程序 

 
* 进程
  * 进程就是一个程序在一个数据集上的一次动态执行过程
  * 进程一般由程序、数据集、进程控制块三部分组成
  * 程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志

* 线程
  * 线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合 和堆栈共同组成
  * 线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能
  * 线程没有自己的系统资源，只拥有在运行时必不可少的资源。但线程可以与同属与同一进程的其他线程共享进程所拥有的其他资源

### 多线程、多进程、多协程的对比
* 一个进程中可以启动N给线程，一个线程中可以启动N个协程
* 多进程multiprocessing
  * 优点：可以利用多核CPU并行运算
  * 缺点：占用资源最多，可启动数目比线程少
  * 适用于：CPU密集型计算
* 多线程threading
  * 优点：相比进程，更轻量级，占用资源少
  * 缺点：
    * 相比进程：多线程只能并发执行，不能利用多CPU(GIL)
    * 相比协程：启动数目有限制，占用内存资源，有线程切换开销 
  * 适用于：IO密集型计算、同时
* 多协程asyncio
  * 优点：内存开销最少，启动协程数量最多
  * 缺点：支持的库有限制（只能aiohttp，不能request ）、代码实现复杂
  * 适用于：IO密集型计算、需要超多任务运行、单现成库支持的场景

### 怎样根据任务选择对应技术
* CPU密集型：使用多进程multiprocessing
* IO密集型：
  * 需要超多任务量？
  * 有现成协程库支持？  
  * 协程实现复杂度可接受？
  * 能用协程就尽量协程，否则多线程
* 怎样规避GIL带来的限制
  * 多线程threading机制依然是有用的，用于IO密集型计算。因为在I/O（read, write, send, recv, etc...）期间，线程会释放GIL，实现CPU和IO的并行，因此多线程用于IO密集型计算依然可以大幅提示速度；但是多线程用于CPU密集型计算，只会拖慢速度 
  * 使用multiprocessing的多进程机制实现并行计算、利用多核CPU优势（Python提供了multiprocessing应对GIL问题）

### 面试问题
#### Python速度慢的两大原因
* 各大公司推荐引擎、搜索引擎、存储引擎等底层对性能要求高的模块依旧用C/C++开发
* 原因1：动态类型语音，边解释边执行
* 原因2：GIL，无法利用多核CPU并发执行

#### 进程/线程/协程之间的关系/区别
* 进程是资源分配的单元，线程是(最小)执行单元
* 进程间切换代价大，线程间切换代价小
* 多个线程共享进程的资源
* 线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除
* 属于同一进程的线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)
* 协程是用户级别的，程序之间的切换由用户自行处理，节省了CPU的调度时间


#### 进程间有哪些通信方式
1. 管道(pipe): 管道是一种半双工的通信方式，数据只能**单向流动**，而且只能在具有亲缘关系的进程间使用，进程的亲缘关系通常是指**父子进程关系**
2. 消息队列通信：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点
3. 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段
4. 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已发生
5. 共享内存通信：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用。来实现进程间的同步和通信
6. socket：套接口也是一种进程间通信机制。与其他通信机制不同的是，它可用于不同机器间的进程通信

#### Python进程之间如何进行通信
* Python中主要提供Queue和Pipe两种方式
* Queue用于多个进程间实现通信
* Pipe是两个进程的通信

#### 什么是GIL锁
* 全局解释锁，每次只能一个线程获得CPU的使用权
* 线程之间的数据是共享的，为了线程安全，为了解决多线程之间的数据完整性和状态同步而加的锁
* 它使得任何时刻仅有一个线程在执行，即使在多核心处理器上，使用GIL的解释器也只运行同一时间执行一个线程

#### select、poll、epoll模型的区别
* I/O多路复用本质就是用select/poll/epoll，去监听多个socket对象，如果其中的socket对象有变化，用户进程就知道了
* select是不断轮询去监听socket，socket个数有限制，一般为1024个
* poll还是采用轮询方式监听，只不过没有个数限制
* epoll并不是采用轮询方式去监听了，而是当socket有变化时通过回调的方式主动告知用户进程
* nginx的网络底层是epoll，而apache的网络底层是select，所以nginx比apache要高效
