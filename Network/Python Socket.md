#### 参考资料
* socket: https://www.cnblogs.com/xuliuzai/p/15506254.html

#### send和recv的通信过程
* 不管是recv还是send都不是直接接收对方的数据，而是操作自己的操作系统内容，不是一个send对应一个recv
* recv:
  * wait data(A操作系统内存->A硬件->B硬件->B操作系统内存)：耗时非常长
  * copy data(操作系统内存->应用程序内存)
* send:
  * copy data(应用程序内存->操作系统内存)

* 粘包问题
  * 只存在TCP中，不会出现在UDP
  * 客户端在很短的时间内连续发送比较小的数据，会被合在一起发送
  * 服务端第一次接收的最大字节小于客户端发送的数据，导致第二次接收拿到的仍是客户端第一次发送的数据（数据已经发送到服务端操作系统中，但是在操作系统内存->应用程序内存时只接收了一部分，剩下的仍在操作系统内存中）

#### TCP和UDP
* TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠服务，首发两端都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包，这样，接收端很难分辨处理，必须提供科学的拆包机制，即面向流的通信是无消息保护边界的
* UDP（user datagram protocol，用户数据协议）是无连接的，面向消息的，提供高效率服务，不会使用块的合并优化算法，由于UDP支持的是一对多的模式，所有接收端的skbuff（套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中有消息头（消息来源地址，端口等信息），这样，对于接收端就容易区分。即面向消息的通信是有保护边界的
* TCP是面向数据流的，于是收发消息不能为空，这就需要在客户端和服务端都添加空消息处理机制，防止程序卡住，而UDP是基于数据报的，即使输入空内容，那也不是空消息，udp协议会帮你封装上消息头